//! Cache for non-critical metadata that can be regenerated.
//!
//! Stores PR URLs, base SHAs, and sync state in `.git/diamond/cache.json`.
//! This data can be regenerated from the forge API or recomputed if lost.

use anyhow::{Context, Result};
use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{self, File};
use std::io::{BufReader, BufWriter};
use std::path::PathBuf;

use crate::program_name::program_name;
use crate::state::find_git_root;

/// Cache file name within .git/diamond/
const CACHE_FILE: &str = "cache.json";

/// Staleness warning thresholds
const WARN_THRESHOLD_HOURS: i64 = 24;
const ERROR_THRESHOLD_DAYS: i64 = 7;

/// Severity level for sync staleness warnings
#[allow(dead_code)] // Will be used in submit staleness check
#[derive(Debug, Clone, PartialEq)]
pub enum StalenessSeverity {
    /// Data is fresh, no warning needed
    Fresh,
    /// Data is stale but usable (> 24 hours)
    Warning,
    /// Data is too stale to use safely (> 7 days)
    Error,
}

/// Warning about stale sync data
#[allow(dead_code)] // Will be used in submit staleness check
#[derive(Debug, Clone)]
pub struct StalenessWarning {
    pub message: String,
    pub suggestion: String,
    pub severity: StalenessSeverity,
}

/// Non-critical metadata cache.
///
/// This data is "nice to have" but can be regenerated:
/// - PR URLs can be fetched from the forge API
/// - Base SHAs can be recomputed from git history
/// - Sync state can be regenerated by running sync again
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Cache {
    /// PR URLs for each branch
    #[serde(default)]
    pub pr_urls: HashMap<String, String>,

    /// Base commit SHAs for detecting external modifications
    #[serde(default)]
    pub base_shas: HashMap<String, String>,

    /// Timestamp of the last successful sync (merged from SyncState)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last_sync_at: Option<DateTime<Utc>>,

    /// Commit SHA of trunk at last sync (merged from SyncState)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trunk_sha_at_sync: Option<String>,
}

#[allow(dead_code)]
impl Cache {
    /// Load cache from .git/diamond/cache.json
    ///
    /// Returns empty cache if file doesn't exist or is corrupt.
    pub fn load() -> Result<Self> {
        let path = Self::cache_path()?;
        Self::load_from(&path)
    }

    /// Load cache from a specific path
    pub fn load_from(path: &PathBuf) -> Result<Self> {
        if !path.exists() {
            return Ok(Self::default());
        }

        let file = File::open(path).context("Failed to open cache file")?;
        let reader = BufReader::new(file);

        Ok(serde_json::from_reader(reader).unwrap_or_else(|e| {
            // Log warning but return empty cache on parse error
            eprintln!("Warning: Cache file corrupted ({}), using empty cache", e);
            Self::default()
        }))
    }

    /// Save cache to .git/diamond/cache.json
    pub fn save(&self) -> Result<()> {
        let path = Self::cache_path()?;
        self.save_to(&path)
    }

    /// Save cache to a specific path
    ///
    /// Uses atomic write (write to temp file, then rename) to prevent
    /// data corruption if the write is interrupted.
    pub fn save_to(&self, path: &PathBuf) -> Result<()> {
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).context("Failed to create cache directory")?;
        }

        // Write to temporary file first to avoid corrupting existing cache on failure
        let temp_path = path.with_extension("json.tmp");

        let file = File::create(&temp_path).context("Failed to create temporary cache file")?;
        let writer = BufWriter::new(file);

        serde_json::to_writer_pretty(writer, self).context("Failed to write cache file")?;

        // Atomic rename (on POSIX systems)
        fs::rename(&temp_path, path).context("Failed to finalize cache file")?;

        Ok(())
    }

    /// Get the cache file path
    fn cache_path() -> Result<PathBuf> {
        let root = find_git_root()?;
        Ok(root.join(".git").join("diamond").join(CACHE_FILE))
    }

    /// Set PR URL for a branch
    pub fn set_pr_url(&mut self, branch: &str, url: &str) {
        self.pr_urls.insert(branch.to_string(), url.to_string());
    }

    /// Get PR URL for a branch
    pub fn get_pr_url(&self, branch: &str) -> Option<&str> {
        self.pr_urls.get(branch).map(|s| s.as_str())
    }

    /// Remove PR URL for a branch
    pub fn remove_pr_url(&mut self, branch: &str) {
        self.pr_urls.remove(branch);
    }

    /// Set base SHA for a branch (for detecting external modifications)
    pub fn set_base_sha(&mut self, branch: &str, sha: &str) {
        self.base_shas.insert(branch.to_string(), sha.to_string());
    }

    /// Get base SHA for a branch
    pub fn get_base_sha(&self, branch: &str) -> Option<&str> {
        self.base_shas.get(branch).map(|s| s.as_str())
    }

    /// Remove base SHA for a branch
    pub fn remove_base_sha(&mut self, branch: &str) {
        self.base_shas.remove(branch);
    }

    /// Remove all data for a branch
    pub fn remove_branch(&mut self, branch: &str) {
        self.pr_urls.remove(branch);
        self.base_shas.remove(branch);
    }

    /// Check if the cache has any data for a branch
    pub fn has_branch(&self, branch: &str) -> bool {
        self.pr_urls.contains_key(branch) || self.base_shas.contains_key(branch)
    }

    /// Clear all cache data
    pub fn clear(&mut self) {
        self.pr_urls.clear();
        self.base_shas.clear();
    }

    /// Rename a branch in the cache
    pub fn rename_branch(&mut self, old_name: &str, new_name: &str) {
        if let Some(url) = self.pr_urls.remove(old_name) {
            self.pr_urls.insert(new_name.to_string(), url);
        }
        if let Some(sha) = self.base_shas.remove(old_name) {
            self.base_shas.insert(new_name.to_string(), sha);
        }
    }

    // =========================================================================
    // Sync State Methods (merged from sync_state.rs)
    // =========================================================================

    /// Record that a sync just completed
    pub fn record_sync(&mut self, trunk_sha: Option<String>) {
        self.last_sync_at = Some(Utc::now());
        self.trunk_sha_at_sync = trunk_sha;
    }

    /// Check if the sync state is stale and return a warning if so
    pub fn check_staleness(&self) -> Option<StalenessWarning> {
        let last_sync = self.last_sync_at?;
        let age = Utc::now().signed_duration_since(last_sync);

        if age > Duration::days(ERROR_THRESHOLD_DAYS) {
            Some(StalenessWarning {
                message: format!("Stack data is {} days old", age.num_days()),
                suggestion: format!("Run `{} sync` to refresh", program_name()),
                severity: StalenessSeverity::Error,
            })
        } else if age > Duration::hours(WARN_THRESHOLD_HOURS) {
            Some(StalenessWarning {
                message: format!("Stack data is {} hours old", age.num_hours()),
                suggestion: format!("Run `{} sync` to refresh", program_name()),
                severity: StalenessSeverity::Warning,
            })
        } else {
            None
        }
    }

    /// Get a human-readable age string for last sync
    pub fn sync_age_string(&self) -> String {
        match self.last_sync_at {
            Some(last_sync) => {
                let age = Utc::now().signed_duration_since(last_sync);

                if age.num_days() > 0 {
                    format!("{} days ago", age.num_days())
                } else if age.num_hours() > 0 {
                    format!("{} hours ago", age.num_hours())
                } else if age.num_minutes() > 0 {
                    format!("{} minutes ago", age.num_minutes())
                } else {
                    "just now".to_string()
                }
            }
            None => "never".to_string(),
        }
    }
}

/// Check for stale sync state and return a warning if applicable
#[allow(dead_code)] // Will be used in submit staleness check
pub fn check_staleness() -> Option<StalenessWarning> {
    match Cache::load() {
        Ok(cache) => {
            if cache.last_sync_at.is_none() {
                // Never synced - warn but don't error
                Some(StalenessWarning {
                    message: "Stack has never been synced".to_string(),
                    suggestion: format!("Run `{} sync` to synchronize with remote", program_name()),
                    severity: StalenessSeverity::Warning,
                })
            } else {
                cache.check_staleness()
            }
        }
        Err(_) => None, // Can't check staleness, proceed silently
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_empty_cache() {
        let cache = Cache::default();
        assert!(cache.pr_urls.is_empty());
        assert!(cache.base_shas.is_empty());
        assert!(!cache.has_branch("any"));
    }

    #[test]
    fn test_pr_url_operations() {
        let mut cache = Cache::default();

        // Initially empty
        assert_eq!(cache.get_pr_url("feature"), None);

        // Set URL
        cache.set_pr_url("feature", "https://github.com/org/repo/pull/42");
        assert_eq!(cache.get_pr_url("feature"), Some("https://github.com/org/repo/pull/42"));

        // Update URL
        cache.set_pr_url("feature", "https://github.com/org/repo/pull/43");
        assert_eq!(cache.get_pr_url("feature"), Some("https://github.com/org/repo/pull/43"));

        // Remove URL
        cache.remove_pr_url("feature");
        assert_eq!(cache.get_pr_url("feature"), None);
    }

    #[test]
    fn test_base_sha_operations() {
        let mut cache = Cache::default();

        // Initially empty
        assert_eq!(cache.get_base_sha("feature"), None);

        // Set SHA
        cache.set_base_sha("feature", "abc123");
        assert_eq!(cache.get_base_sha("feature"), Some("abc123"));

        // Update SHA
        cache.set_base_sha("feature", "def456");
        assert_eq!(cache.get_base_sha("feature"), Some("def456"));

        // Remove SHA
        cache.remove_base_sha("feature");
        assert_eq!(cache.get_base_sha("feature"), None);
    }

    #[test]
    fn test_remove_branch() {
        let mut cache = Cache::default();

        cache.set_pr_url("feature", "https://example.com/pr/1");
        cache.set_base_sha("feature", "abc123");

        assert!(cache.has_branch("feature"));

        cache.remove_branch("feature");

        assert!(!cache.has_branch("feature"));
        assert_eq!(cache.get_pr_url("feature"), None);
        assert_eq!(cache.get_base_sha("feature"), None);
    }

    #[test]
    fn test_rename_branch() {
        let mut cache = Cache::default();

        cache.set_pr_url("old-name", "https://example.com/pr/1");
        cache.set_base_sha("old-name", "abc123");

        cache.rename_branch("old-name", "new-name");

        assert!(!cache.has_branch("old-name"));
        assert!(cache.has_branch("new-name"));
        assert_eq!(cache.get_pr_url("new-name"), Some("https://example.com/pr/1"));
        assert_eq!(cache.get_base_sha("new-name"), Some("abc123"));
    }

    #[test]
    fn test_clear() {
        let mut cache = Cache::default();

        cache.set_pr_url("feature-1", "https://example.com/pr/1");
        cache.set_pr_url("feature-2", "https://example.com/pr/2");
        cache.set_base_sha("feature-1", "abc123");

        cache.clear();

        assert!(cache.pr_urls.is_empty());
        assert!(cache.base_shas.is_empty());
    }

    #[test]
    fn test_save_and_load() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("cache.json");

        // Create and save
        let mut cache = Cache::default();
        cache.set_pr_url("feature", "https://example.com/pr/42");
        cache.set_base_sha("feature", "abc123def456");
        cache.save_to(&path)?;

        // Load and verify
        let loaded = Cache::load_from(&path)?;
        assert_eq!(loaded.get_pr_url("feature"), Some("https://example.com/pr/42"));
        assert_eq!(loaded.get_base_sha("feature"), Some("abc123def456"));

        Ok(())
    }

    #[test]
    fn test_load_nonexistent_returns_empty() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("nonexistent.json");

        let cache = Cache::load_from(&path)?;
        assert!(cache.pr_urls.is_empty());
        assert!(cache.base_shas.is_empty());

        Ok(())
    }

    #[test]
    fn test_load_corrupt_returns_empty() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("corrupt.json");

        // Write invalid JSON
        fs::write(&path, "{ this is not valid json }")?;

        // Should return empty cache, not error
        let cache = Cache::load_from(&path)?;
        assert!(cache.pr_urls.is_empty());

        Ok(())
    }

    #[test]
    fn test_save_creates_parent_directory() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("nested").join("dirs").join("cache.json");

        let cache = Cache::default();
        cache.save_to(&path)?;

        assert!(path.exists());

        Ok(())
    }

    #[test]
    fn test_serialization_format() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("cache.json");

        let mut cache = Cache::default();
        cache.set_pr_url("feature", "https://example.com");
        cache.save_to(&path)?;

        // Read raw content and verify it's pretty-printed JSON
        let content = fs::read_to_string(&path)?;
        assert!(content.contains("\"pr_urls\""));
        assert!(content.contains("\"feature\""));
        assert!(content.contains('\n')); // Pretty printed

        Ok(())
    }

    // =========================================================================
    // Cache Corruption Recovery Tests
    // =========================================================================

    #[test]
    fn test_cache_recovery_from_truncated_file() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("truncated.json");

        // Write truncated JSON (valid start but cut off mid-stream)
        fs::write(&path, r#"{ "pr_urls": { "feature": "https://example"#)?;

        // Should return empty cache, not error
        let cache = Cache::load_from(&path)?;
        assert!(cache.pr_urls.is_empty());

        // Verify we can save a new cache over the corrupted file
        let mut new_cache = Cache::default();
        new_cache.set_pr_url("feature", "https://example.com/pr/42");
        new_cache.save_to(&path)?;

        // Verify the save worked
        let loaded = Cache::load_from(&path)?;
        assert_eq!(loaded.get_pr_url("feature"), Some("https://example.com/pr/42"));

        Ok(())
    }

    #[test]
    fn test_cache_recovery_from_binary_garbage() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("garbage.json");

        // Write random binary data (not even remotely valid JSON)
        let garbage: Vec<u8> = (0..100).map(|i| (i * 7 + 13) as u8).collect();
        fs::write(&path, garbage)?;

        // Should return empty cache, not error or panic
        let cache = Cache::load_from(&path)?;
        assert!(cache.pr_urls.is_empty());
        assert!(cache.base_shas.is_empty());

        Ok(())
    }

    #[test]
    fn test_cache_recovery_from_empty_file() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("empty.json");

        // Write an empty file
        fs::write(&path, "")?;

        // Should return empty cache, not error
        let cache = Cache::load_from(&path)?;
        assert!(cache.pr_urls.is_empty());

        Ok(())
    }

    #[test]
    fn test_cache_recovery_from_null_bytes() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("nulls.json");

        // Write null bytes (could happen with disk corruption)
        let nulls: Vec<u8> = vec![0u8; 50];
        fs::write(&path, nulls)?;

        // Should return empty cache, not error
        let cache = Cache::load_from(&path)?;
        assert!(cache.pr_urls.is_empty());

        Ok(())
    }

    #[test]
    fn test_cache_recovery_from_valid_but_wrong_structure() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("wrong_structure.json");

        // Write valid JSON but with wrong structure
        fs::write(&path, r#"{ "foo": 123, "bar": [1, 2, 3] }"#)?;

        // Should return a cache with default (empty) values for missing fields
        let cache = Cache::load_from(&path)?;
        assert!(cache.pr_urls.is_empty());
        assert!(cache.base_shas.is_empty());

        Ok(())
    }

    // =========================================================================
    // Sync State Tests (merged from sync_state.rs)
    // =========================================================================

    #[test]
    fn test_sync_state_record_and_check() {
        let mut cache = Cache::default();

        // Initially no sync
        assert!(cache.last_sync_at.is_none());
        assert_eq!(cache.sync_age_string(), "never");

        // Record sync
        cache.record_sync(Some("abc123".to_string()));
        assert!(cache.last_sync_at.is_some());
        assert_eq!(cache.trunk_sha_at_sync, Some("abc123".to_string()));
        assert_eq!(cache.sync_age_string(), "just now");
    }

    #[test]
    fn test_sync_staleness_fresh() {
        let cache = Cache {
            last_sync_at: Some(Utc::now()),
            ..Default::default()
        };

        let warning = cache.check_staleness();
        assert!(warning.is_none());
    }

    #[test]
    fn test_sync_staleness_warning() {
        let cache = Cache {
            last_sync_at: Some(Utc::now() - Duration::hours(25)),
            ..Default::default()
        };

        let warning = cache.check_staleness();
        assert!(warning.is_some());
        assert_eq!(warning.unwrap().severity, StalenessSeverity::Warning);
    }

    #[test]
    fn test_sync_staleness_error() {
        let cache = Cache {
            last_sync_at: Some(Utc::now() - Duration::days(8)),
            ..Default::default()
        };

        let warning = cache.check_staleness();
        assert!(warning.is_some());
        assert_eq!(warning.unwrap().severity, StalenessSeverity::Error);
    }

    #[test]
    fn test_sync_age_string_hours() {
        let cache = Cache {
            last_sync_at: Some(Utc::now() - Duration::hours(5)),
            ..Default::default()
        };

        let age_str = cache.sync_age_string();
        assert!(age_str.contains("hours ago"));
    }

    #[test]
    fn test_sync_state_save_and_load() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("cache.json");

        let mut cache = Cache::default();
        cache.record_sync(Some("abc123".to_string()));
        cache.save_to(&path)?;

        let loaded = Cache::load_from(&path)?;
        assert!(loaded.last_sync_at.is_some());
        assert_eq!(loaded.trunk_sha_at_sync, Some("abc123".to_string()));

        Ok(())
    }

    #[test]
    fn test_sync_state_backward_compat() -> Result<()> {
        let dir = tempdir()?;
        let path = dir.path().join("cache.json");

        // Write old-style cache without sync fields
        fs::write(&path, r#"{"pr_urls": {}, "base_shas": {}}"#)?;

        // Should load fine with None sync fields
        let cache = Cache::load_from(&path)?;
        assert!(cache.last_sync_at.is_none());
        assert!(cache.trunk_sha_at_sync.is_none());

        Ok(())
    }

    #[test]
    fn test_old_cache_with_pr_info_loads_successfully() -> Result<()> {
        // Verifies backward compatibility: old cache files that contain the removed
        // pr_info field should load without errors (the field is silently ignored)
        let dir = tempdir()?;
        let path = dir.path().join("cache.json");

        // Write old-style cache WITH pr_info field (now removed from struct)
        fs::write(
            &path,
            r#"{
                "pr_urls": {"feature": "https://github.com/org/repo/pull/42"},
                "base_shas": {"feature": "abc123"},
                "pr_info": {"feature": {"number": 42, "state": "open", "author": "alice"}}
            }"#,
        )?;

        // Should load successfully - pr_info is ignored, other fields preserved
        let cache = Cache::load_from(&path)?;
        assert_eq!(cache.get_pr_url("feature"), Some("https://github.com/org/repo/pull/42"));
        assert_eq!(cache.get_base_sha("feature"), Some("abc123"));

        // Saving should write a clean cache without pr_info
        cache.save_to(&path)?;
        let content = fs::read_to_string(&path)?;
        assert!(!content.contains("pr_info"), "Saved cache should not contain pr_info");

        Ok(())
    }

    #[test]
    fn test_sync_state_clear_resets_sync() {
        let mut cache = Cache::default();
        cache.record_sync(Some("abc123".to_string()));
        assert!(cache.last_sync_at.is_some());

        cache.clear();

        // Note: clear() only clears branch-related data, not sync state
        // This is intentional - sync state is global, not per-branch
        assert!(cache.last_sync_at.is_some());
    }

    #[test]
    fn test_sync_staleness_never_synced() {
        // A fresh cache with no sync state should return None from check_staleness
        // (the "never synced" warning is handled by the module-level check_staleness function)
        let cache = Cache::default();
        assert!(cache.last_sync_at.is_none());
        assert!(cache.check_staleness().is_none()); // No warning because we can't compute staleness
    }

    #[test]
    fn test_sync_state_without_trunk_sha() {
        let mut cache = Cache::default();
        cache.record_sync(None); // Sync without knowing trunk SHA

        assert!(cache.last_sync_at.is_some());
        assert!(cache.trunk_sha_at_sync.is_none());
        assert_eq!(cache.sync_age_string(), "just now");
    }

    #[test]
    fn test_sync_age_string_days() {
        let cache = Cache {
            last_sync_at: Some(Utc::now() - Duration::days(3)),
            ..Default::default()
        };

        let age_str = cache.sync_age_string();
        assert!(age_str.contains("days ago"), "Expected 'days ago', got: {}", age_str);
    }

    #[test]
    fn test_sync_age_string_minutes() {
        let cache = Cache {
            last_sync_at: Some(Utc::now() - Duration::minutes(15)),
            ..Default::default()
        };

        let age_str = cache.sync_age_string();
        assert!(
            age_str.contains("minutes ago"),
            "Expected 'minutes ago', got: {}",
            age_str
        );
    }
}
